{"ast":null,"code":"/** @license React v16.5.2\n * react-dom-test-utils.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    var _assign = require('object-assign');\n\n    var React = require('react');\n\n    var ReactDOM = require('react-dom');\n    /**\n     * Use invariant() to assert state which your program assumes to be true.\n     *\n     * Provide sprintf-style format (only %s is supported) and arguments\n     * to provide information about what broke and what you were\n     * expecting.\n     *\n     * The invariant message will be stripped in production, but the invariant\n     * will remain to ensure logic does not differ in production.\n     */\n\n\n    var validateFormat = function validateFormat() {};\n\n    {\n      validateFormat = function validateFormat(format) {\n        if (format === undefined) {\n          throw new Error('invariant requires an error message argument');\n        }\n      };\n    }\n\n    function invariant(condition, format, a, b, c, d, e, f) {\n      validateFormat(format);\n\n      if (!condition) {\n        var error = void 0;\n\n        if (format === undefined) {\n          error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n        } else {\n          var args = [a, b, c, d, e, f];\n          var argIndex = 0;\n          error = new Error(format.replace(/%s/g, function () {\n            return args[argIndex++];\n          }));\n          error.name = 'Invariant Violation';\n        }\n\n        error.framesToPop = 1; // we don't care about invariant's own frame\n\n        throw error;\n      }\n    } // Relying on the `invariant()` implementation lets us\n    // preserve the format and params in the www builds.\n\n    /**\n     * Similar to invariant but only logs a warning if the condition is not met.\n     * This can be used to log issues in development environments in critical\n     * paths. Removing the logging code for production environments will keep the\n     * same logic and follow the same code paths.\n     */\n\n\n    var warningWithoutStack = function warningWithoutStack() {};\n\n    {\n      warningWithoutStack = function warningWithoutStack(condition, format) {\n        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n          args[_key - 2] = arguments[_key];\n        }\n\n        if (format === undefined) {\n          throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');\n        }\n\n        if (args.length > 8) {\n          // Check before the condition to catch violations early.\n          throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n        }\n\n        if (condition) {\n          return;\n        }\n\n        if (typeof console !== 'undefined') {\n          var _args$map = args.map(function (item) {\n            return '' + item;\n          }),\n              a = _args$map[0],\n              b = _args$map[1],\n              c = _args$map[2],\n              d = _args$map[3],\n              e = _args$map[4],\n              f = _args$map[5],\n              g = _args$map[6],\n              h = _args$map[7];\n\n          var message = 'Warning: ' + format; // We intentionally don't use spread (or .apply) because it breaks IE9:\n          // https://github.com/facebook/react/issues/13610\n\n          switch (args.length) {\n            case 0:\n              console.error(message);\n              break;\n\n            case 1:\n              console.error(message, a);\n              break;\n\n            case 2:\n              console.error(message, a, b);\n              break;\n\n            case 3:\n              console.error(message, a, b, c);\n              break;\n\n            case 4:\n              console.error(message, a, b, c, d);\n              break;\n\n            case 5:\n              console.error(message, a, b, c, d, e);\n              break;\n\n            case 6:\n              console.error(message, a, b, c, d, e, f);\n              break;\n\n            case 7:\n              console.error(message, a, b, c, d, e, f, g);\n              break;\n\n            case 8:\n              console.error(message, a, b, c, d, e, f, g, h);\n              break;\n\n            default:\n              throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n          }\n        }\n\n        try {\n          // --- Welcome to debugging React ---\n          // This error was thrown as a convenience so that you can use this stack\n          // to find the callsite that caused this warning to fire.\n          var argIndex = 0;\n\n          var _message = 'Warning: ' + format.replace(/%s/g, function () {\n            return args[argIndex++];\n          });\n\n          throw new Error(_message);\n        } catch (x) {}\n      };\n    }\n    var warningWithoutStack$1 = warningWithoutStack;\n    /**\n     * `ReactInstanceMap` maintains a mapping from a public facing stateful\n     * instance (key) and the internal representation (value). This allows public\n     * methods to accept the user facing instance as an argument and map them back\n     * to internal methods.\n     *\n     * Note that this module is currently shared and assumed to be stateless.\n     * If this becomes an actual Map, that will break.\n     */\n\n    /**\n     * This API should be called `delete` but we'd have to make sure to always\n     * transform these to strings for IE support. When this transform is fully\n     * supported we can rename it.\n     */\n\n    function get(key) {\n      return key._reactInternalFiber;\n    }\n\n    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n    var FunctionalComponent = 0;\n    var FunctionalComponentLazy = 1;\n    var ClassComponent = 2;\n    var ClassComponentLazy = 3; // Before we know whether it is functional or class\n\n    var HostRoot = 5; // Root of a host tree. Could be nested inside another node.\n    // A subtree. Could be an entry point to a different renderer.\n\n    var HostComponent = 7;\n    var HostText = 8; // Don't change these two values. They're used by React Dev Tools.\n\n    var NoEffect =\n    /*              */\n    0; // You can change the rest (and add more).\n\n    var Placement =\n    /*             */\n    2; // Update & Callback & Ref & Snapshot\n    // Union of all host effects\n\n    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n    var MOUNTING = 1;\n    var MOUNTED = 2;\n    var UNMOUNTED = 3;\n\n    function isFiberMountedImpl(fiber) {\n      var node = fiber;\n\n      if (!fiber.alternate) {\n        // If there is no alternate, this might be a new tree that isn't inserted\n        // yet. If it is, then it will have a pending insertion effect on it.\n        if ((node.effectTag & Placement) !== NoEffect) {\n          return MOUNTING;\n        }\n\n        while (node.return) {\n          node = node.return;\n\n          if ((node.effectTag & Placement) !== NoEffect) {\n            return MOUNTING;\n          }\n        }\n      } else {\n        while (node.return) {\n          node = node.return;\n        }\n      }\n\n      if (node.tag === HostRoot) {\n        // TODO: Check if this was a nested HostRoot when used with\n        // renderContainerIntoSubtree.\n        return MOUNTED;\n      } // If we didn't hit the root, that means that we're in an disconnected tree\n      // that has been unmounted.\n\n\n      return UNMOUNTED;\n    }\n\n    function assertIsMounted(fiber) {\n      !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    }\n\n    function findCurrentFiberUsingSlowPath(fiber) {\n      var alternate = fiber.alternate;\n\n      if (!alternate) {\n        // If there is no alternate, then we only need to check if it is mounted.\n        var state = isFiberMountedImpl(fiber);\n        !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n\n        if (state === MOUNTING) {\n          return null;\n        }\n\n        return fiber;\n      } // If we have two possible branches, we'll walk backwards up to the root\n      // to see what path the root points to. On the way we may hit one of the\n      // special cases and we'll deal with them.\n\n\n      var a = fiber;\n      var b = alternate;\n\n      while (true) {\n        var parentA = a.return;\n        var parentB = parentA ? parentA.alternate : null;\n\n        if (!parentA || !parentB) {\n          // We're at the root.\n          break;\n        } // If both copies of the parent fiber point to the same child, we can\n        // assume that the child is current. This happens when we bailout on low\n        // priority: the bailed out fiber's child reuses the current child.\n\n\n        if (parentA.child === parentB.child) {\n          var child = parentA.child;\n\n          while (child) {\n            if (child === a) {\n              // We've determined that A is the current branch.\n              assertIsMounted(parentA);\n              return fiber;\n            }\n\n            if (child === b) {\n              // We've determined that B is the current branch.\n              assertIsMounted(parentA);\n              return alternate;\n            }\n\n            child = child.sibling;\n          } // We should never have an alternate for any mounting node. So the only\n          // way this could possibly happen is if this was unmounted, if at all.\n\n\n          invariant(false, 'Unable to find node on an unmounted component.');\n        }\n\n        if (a.return !== b.return) {\n          // The return pointer of A and the return pointer of B point to different\n          // fibers. We assume that return pointers never criss-cross, so A must\n          // belong to the child set of A.return, and B must belong to the child\n          // set of B.return.\n          a = parentA;\n          b = parentB;\n        } else {\n          // The return pointers point to the same fiber. We'll have to use the\n          // default, slow path: scan the child sets of each parent alternate to see\n          // which child belongs to which set.\n          //\n          // Search parent A's child set\n          var didFindChild = false;\n          var _child = parentA.child;\n\n          while (_child) {\n            if (_child === a) {\n              didFindChild = true;\n              a = parentA;\n              b = parentB;\n              break;\n            }\n\n            if (_child === b) {\n              didFindChild = true;\n              b = parentA;\n              a = parentB;\n              break;\n            }\n\n            _child = _child.sibling;\n          }\n\n          if (!didFindChild) {\n            // Search parent B's child set\n            _child = parentB.child;\n\n            while (_child) {\n              if (_child === a) {\n                didFindChild = true;\n                a = parentB;\n                b = parentA;\n                break;\n              }\n\n              if (_child === b) {\n                didFindChild = true;\n                b = parentB;\n                a = parentA;\n                break;\n              }\n\n              _child = _child.sibling;\n            }\n\n            !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n          }\n        }\n\n        !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      } // If the root is not a host container, we're in a disconnected tree. I.e.\n      // unmounted.\n\n\n      !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n\n      if (a.stateNode.current === a) {\n        // We've determined that A is the current branch.\n        return fiber;\n      } // Otherwise B has to be current branch.\n\n\n      return alternate;\n    }\n    /* eslint valid-typeof: 0 */\n\n\n    var EVENT_POOL_SIZE = 10;\n    /**\n     * @interface Event\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\n     */\n\n    var EventInterface = {\n      type: null,\n      target: null,\n      // currentTarget is set when dispatching; no use in copying it here\n      currentTarget: function currentTarget() {\n        return null;\n      },\n      eventPhase: null,\n      bubbles: null,\n      cancelable: null,\n      timeStamp: function timeStamp(event) {\n        return event.timeStamp || Date.now();\n      },\n      defaultPrevented: null,\n      isTrusted: null\n    };\n\n    function functionThatReturnsTrue() {\n      return true;\n    }\n\n    function functionThatReturnsFalse() {\n      return false;\n    }\n    /**\n     * Synthetic events are dispatched by event plugins, typically in response to a\n     * top-level event delegation handler.\n     *\n     * These systems should generally use pooling to reduce the frequency of garbage\n     * collection. The system should check `isPersistent` to determine whether the\n     * event should be released into the pool after being dispatched. Users that\n     * need a persisted event should invoke `persist`.\n     *\n     * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n     * normalizing browser quirks. Subclasses do not necessarily have to implement a\n     * DOM interface; custom application-specific events can also subclass this.\n     *\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {*} targetInst Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @param {DOMEventTarget} nativeEventTarget Target node.\n     */\n\n\n    function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n      {\n        // these have a getter/setter for warnings\n        delete this.nativeEvent;\n        delete this.preventDefault;\n        delete this.stopPropagation;\n        delete this.isDefaultPrevented;\n        delete this.isPropagationStopped;\n      }\n      this.dispatchConfig = dispatchConfig;\n      this._targetInst = targetInst;\n      this.nativeEvent = nativeEvent;\n      var Interface = this.constructor.Interface;\n\n      for (var propName in Interface) {\n        if (!Interface.hasOwnProperty(propName)) {\n          continue;\n        }\n\n        {\n          delete this[propName]; // this has a getter/setter for warnings\n        }\n        var normalize = Interface[propName];\n\n        if (normalize) {\n          this[propName] = normalize(nativeEvent);\n        } else {\n          if (propName === 'target') {\n            this.target = nativeEventTarget;\n          } else {\n            this[propName] = nativeEvent[propName];\n          }\n        }\n      }\n\n      var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n\n      if (defaultPrevented) {\n        this.isDefaultPrevented = functionThatReturnsTrue;\n      } else {\n        this.isDefaultPrevented = functionThatReturnsFalse;\n      }\n\n      this.isPropagationStopped = functionThatReturnsFalse;\n      return this;\n    }\n\n    _assign(SyntheticEvent.prototype, {\n      preventDefault: function preventDefault() {\n        this.defaultPrevented = true;\n        var event = this.nativeEvent;\n\n        if (!event) {\n          return;\n        }\n\n        if (event.preventDefault) {\n          event.preventDefault();\n        } else if (typeof event.returnValue !== 'unknown') {\n          event.returnValue = false;\n        }\n\n        this.isDefaultPrevented = functionThatReturnsTrue;\n      },\n      stopPropagation: function stopPropagation() {\n        var event = this.nativeEvent;\n\n        if (!event) {\n          return;\n        }\n\n        if (event.stopPropagation) {\n          event.stopPropagation();\n        } else if (typeof event.cancelBubble !== 'unknown') {\n          // The ChangeEventPlugin registers a \"propertychange\" event for\n          // IE. This event does not support bubbling or cancelling, and\n          // any references to cancelBubble throw \"Member not found\".  A\n          // typeof check of \"unknown\" circumvents this issue (and is also\n          // IE specific).\n          event.cancelBubble = true;\n        }\n\n        this.isPropagationStopped = functionThatReturnsTrue;\n      },\n\n      /**\n       * We release all dispatched `SyntheticEvent`s after each event loop, adding\n       * them back into the pool. This allows a way to hold onto a reference that\n       * won't be added back into the pool.\n       */\n      persist: function persist() {\n        this.isPersistent = functionThatReturnsTrue;\n      },\n\n      /**\n       * Checks if this event should be released back into the pool.\n       *\n       * @return {boolean} True if this should not be released, false otherwise.\n       */\n      isPersistent: functionThatReturnsFalse,\n\n      /**\n       * `PooledClass` looks for `destructor` on each instance it releases.\n       */\n      destructor: function destructor() {\n        var Interface = this.constructor.Interface;\n\n        for (var propName in Interface) {\n          {\n            Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n          }\n        }\n\n        this.dispatchConfig = null;\n        this._targetInst = null;\n        this.nativeEvent = null;\n        this.isDefaultPrevented = functionThatReturnsFalse;\n        this.isPropagationStopped = functionThatReturnsFalse;\n        this._dispatchListeners = null;\n        this._dispatchInstances = null;\n        {\n          Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n          Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));\n          Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));\n          Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));\n          Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));\n        }\n      }\n    });\n\n    SyntheticEvent.Interface = EventInterface;\n    /**\n     * Helper to reduce boilerplate when creating subclasses.\n     */\n\n    SyntheticEvent.extend = function (Interface) {\n      var Super = this;\n\n      var E = function E() {};\n\n      E.prototype = Super.prototype;\n      var prototype = new E();\n\n      function Class() {\n        return Super.apply(this, arguments);\n      }\n\n      _assign(prototype, Class.prototype);\n\n      Class.prototype = prototype;\n      Class.prototype.constructor = Class;\n      Class.Interface = _assign({}, Super.Interface, Interface);\n      Class.extend = Super.extend;\n      addEventPoolingTo(Class);\n      return Class;\n    };\n\n    addEventPoolingTo(SyntheticEvent);\n    /**\n     * Helper to nullify syntheticEvent instance properties when destructing\n     *\n     * @param {String} propName\n     * @param {?object} getVal\n     * @return {object} defineProperty object\n     */\n\n    function getPooledWarningPropertyDefinition(propName, getVal) {\n      var isFunction = typeof getVal === 'function';\n      return {\n        configurable: true,\n        set: set,\n        get: get\n      };\n\n      function set(val) {\n        var action = isFunction ? 'setting the method' : 'setting the property';\n        warn(action, 'This is effectively a no-op');\n        return val;\n      }\n\n      function get() {\n        var action = isFunction ? 'accessing the method' : 'accessing the property';\n        var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n        warn(action, result);\n        return getVal;\n      }\n\n      function warn(action, result) {\n        var warningCondition = false;\n        !warningCondition ? warningWithoutStack$1(false, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;\n      }\n    }\n\n    function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n      var EventConstructor = this;\n\n      if (EventConstructor.eventPool.length) {\n        var instance = EventConstructor.eventPool.pop();\n        EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n        return instance;\n      }\n\n      return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n    }\n\n    function releasePooledEvent(event) {\n      var EventConstructor = this;\n      !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance into a pool of a different type.') : void 0;\n      event.destructor();\n\n      if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n        EventConstructor.eventPool.push(event);\n      }\n    }\n\n    function addEventPoolingTo(EventConstructor) {\n      EventConstructor.eventPool = [];\n      EventConstructor.getPooled = getPooledEvent;\n      EventConstructor.release = releasePooledEvent;\n    }\n    /**\n     * Forked from fbjs/warning:\n     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n     *\n     * Only change is we use console.warn instead of console.error,\n     * and do nothing when 'console' is not supported.\n     * This really simplifies the code.\n     * ---\n     * Similar to invariant but only logs a warning if the condition is not met.\n     * This can be used to log issues in development environments in critical\n     * paths. Removing the logging code for production environments will keep the\n     * same logic and follow the same code paths.\n     */\n\n\n    var lowPriorityWarning = function lowPriorityWarning() {};\n\n    {\n      var printWarning = function printWarning(format) {\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        var argIndex = 0;\n        var message = 'Warning: ' + format.replace(/%s/g, function () {\n          return args[argIndex++];\n        });\n\n        if (typeof console !== 'undefined') {\n          console.warn(message);\n        }\n\n        try {\n          // --- Welcome to debugging React ---\n          // This error was thrown as a convenience so that you can use this stack\n          // to find the callsite that caused this warning to fire.\n          throw new Error(message);\n        } catch (x) {}\n      };\n\n      lowPriorityWarning = function lowPriorityWarning(condition, format) {\n        if (format === undefined) {\n          throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');\n        }\n\n        if (!condition) {\n          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n            args[_key2 - 2] = arguments[_key2];\n          }\n\n          printWarning.apply(undefined, [format].concat(args));\n        }\n      };\n    }\n    var lowPriorityWarning$1 = lowPriorityWarning;\n    /**\n     * HTML nodeType values that represent the type of the node\n     */\n\n    var ELEMENT_NODE = 1; // Do not uses the below two methods directly!\n    // Instead use constants exported from DOMTopLevelEventTypes in ReactDOM.\n    // (It is the only module that is allowed to access these methods.)\n\n    function unsafeCastStringToDOMTopLevelType(topLevelType) {\n      return topLevelType;\n    }\n\n    var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n    /**\n     * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n     *\n     * @param {string} styleProp\n     * @param {string} eventName\n     * @returns {object}\n     */\n\n    function makePrefixMap(styleProp, eventName) {\n      var prefixes = {};\n      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n      prefixes['Webkit' + styleProp] = 'webkit' + eventName;\n      prefixes['Moz' + styleProp] = 'moz' + eventName;\n      return prefixes;\n    }\n    /**\n     * A list of event names to a configurable list of vendor prefixes.\n     */\n\n\n    var vendorPrefixes = {\n      animationend: makePrefixMap('Animation', 'AnimationEnd'),\n      animationiteration: makePrefixMap('Animation', 'AnimationIteration'),\n      animationstart: makePrefixMap('Animation', 'AnimationStart'),\n      transitionend: makePrefixMap('Transition', 'TransitionEnd')\n    };\n    /**\n     * Event names that have already been detected and prefixed (if applicable).\n     */\n\n    var prefixedEventNames = {};\n    /**\n     * Element to check for prefixes on.\n     */\n\n    var style = {};\n    /**\n     * Bootstrap if a DOM exists.\n     */\n\n    if (canUseDOM) {\n      style = document.createElement('div').style; // On some platforms, in particular some releases of Android 4.x,\n      // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n      // style object but the events that fire will still be prefixed, so we need\n      // to check if the un-prefixed events are usable, and if not remove them from the map.\n\n      if (!('AnimationEvent' in window)) {\n        delete vendorPrefixes.animationend.animation;\n        delete vendorPrefixes.animationiteration.animation;\n        delete vendorPrefixes.animationstart.animation;\n      } // Same as above\n\n\n      if (!('TransitionEvent' in window)) {\n        delete vendorPrefixes.transitionend.transition;\n      }\n    }\n    /**\n     * Attempts to determine the correct vendor prefixed event name.\n     *\n     * @param {string} eventName\n     * @returns {string}\n     */\n\n\n    function getVendorPrefixedEventName(eventName) {\n      if (prefixedEventNames[eventName]) {\n        return prefixedEventNames[eventName];\n      } else if (!vendorPrefixes[eventName]) {\n        return eventName;\n      }\n\n      var prefixMap = vendorPrefixes[eventName];\n\n      for (var styleProp in prefixMap) {\n        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\n          return prefixedEventNames[eventName] = prefixMap[styleProp];\n        }\n      }\n\n      return eventName;\n    }\n    /**\n     * To identify top level events in ReactDOM, we use constants defined by this\n     * module. This is the only module that uses the unsafe* methods to express\n     * that the constants actually correspond to the browser event names. This lets\n     * us save some bundle size by avoiding a top level type -> event name map.\n     * The rest of ReactDOM code should import top level types from this file.\n     */\n\n\n    var TOP_ABORT = unsafeCastStringToDOMTopLevelType('abort');\n    var TOP_ANIMATION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationend'));\n    var TOP_ANIMATION_ITERATION = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationiteration'));\n    var TOP_ANIMATION_START = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationstart'));\n    var TOP_BLUR = unsafeCastStringToDOMTopLevelType('blur');\n    var TOP_CAN_PLAY = unsafeCastStringToDOMTopLevelType('canplay');\n    var TOP_CAN_PLAY_THROUGH = unsafeCastStringToDOMTopLevelType('canplaythrough');\n    var TOP_CANCEL = unsafeCastStringToDOMTopLevelType('cancel');\n    var TOP_CHANGE = unsafeCastStringToDOMTopLevelType('change');\n    var TOP_CLICK = unsafeCastStringToDOMTopLevelType('click');\n    var TOP_CLOSE = unsafeCastStringToDOMTopLevelType('close');\n    var TOP_COMPOSITION_END = unsafeCastStringToDOMTopLevelType('compositionend');\n    var TOP_COMPOSITION_START = unsafeCastStringToDOMTopLevelType('compositionstart');\n    var TOP_COMPOSITION_UPDATE = unsafeCastStringToDOMTopLevelType('compositionupdate');\n    var TOP_CONTEXT_MENU = unsafeCastStringToDOMTopLevelType('contextmenu');\n    var TOP_COPY = unsafeCastStringToDOMTopLevelType('copy');\n    var TOP_CUT = unsafeCastStringToDOMTopLevelType('cut');\n    var TOP_DOUBLE_CLICK = unsafeCastStringToDOMTopLevelType('dblclick');\n    var TOP_DRAG = unsafeCastStringToDOMTopLevelType('drag');\n    var TOP_DRAG_END = unsafeCastStringToDOMTopLevelType('dragend');\n    var TOP_DRAG_ENTER = unsafeCastStringToDOMTopLevelType('dragenter');\n    var TOP_DRAG_EXIT = unsafeCastStringToDOMTopLevelType('dragexit');\n    var TOP_DRAG_LEAVE = unsafeCastStringToDOMTopLevelType('dragleave');\n    var TOP_DRAG_OVER = unsafeCastStringToDOMTopLevelType('dragover');\n    var TOP_DRAG_START = unsafeCastStringToDOMTopLevelType('dragstart');\n    var TOP_DROP = unsafeCastStringToDOMTopLevelType('drop');\n    var TOP_DURATION_CHANGE = unsafeCastStringToDOMTopLevelType('durationchange');\n    var TOP_EMPTIED = unsafeCastStringToDOMTopLevelType('emptied');\n    var TOP_ENCRYPTED = unsafeCastStringToDOMTopLevelType('encrypted');\n    var TOP_ENDED = unsafeCastStringToDOMTopLevelType('ended');\n    var TOP_ERROR = unsafeCastStringToDOMTopLevelType('error');\n    var TOP_FOCUS = unsafeCastStringToDOMTopLevelType('focus');\n    var TOP_INPUT = unsafeCastStringToDOMTopLevelType('input');\n    var TOP_KEY_DOWN = unsafeCastStringToDOMTopLevelType('keydown');\n    var TOP_KEY_PRESS = unsafeCastStringToDOMTopLevelType('keypress');\n    var TOP_KEY_UP = unsafeCastStringToDOMTopLevelType('keyup');\n    var TOP_LOAD = unsafeCastStringToDOMTopLevelType('load');\n    var TOP_LOAD_START = unsafeCastStringToDOMTopLevelType('loadstart');\n    var TOP_LOADED_DATA = unsafeCastStringToDOMTopLevelType('loadeddata');\n    var TOP_LOADED_METADATA = unsafeCastStringToDOMTopLevelType('loadedmetadata');\n    var TOP_MOUSE_DOWN = unsafeCastStringToDOMTopLevelType('mousedown');\n    var TOP_MOUSE_MOVE = unsafeCastStringToDOMTopLevelType('mousemove');\n    var TOP_MOUSE_OUT = unsafeCastStringToDOMTopLevelType('mouseout');\n    var TOP_MOUSE_OVER = unsafeCastStringToDOMTopLevelType('mouseover');\n    var TOP_MOUSE_UP = unsafeCastStringToDOMTopLevelType('mouseup');\n    var TOP_PASTE = unsafeCastStringToDOMTopLevelType('paste');\n    var TOP_PAUSE = unsafeCastStringToDOMTopLevelType('pause');\n    var TOP_PLAY = unsafeCastStringToDOMTopLevelType('play');\n    var TOP_PLAYING = unsafeCastStringToDOMTopLevelType('playing');\n    var TOP_PROGRESS = unsafeCastStringToDOMTopLevelType('progress');\n    var TOP_RATE_CHANGE = unsafeCastStringToDOMTopLevelType('ratechange');\n    var TOP_SCROLL = unsafeCastStringToDOMTopLevelType('scroll');\n    var TOP_SEEKED = unsafeCastStringToDOMTopLevelType('seeked');\n    var TOP_SEEKING = unsafeCastStringToDOMTopLevelType('seeking');\n    var TOP_SELECTION_CHANGE = unsafeCastStringToDOMTopLevelType('selectionchange');\n    var TOP_STALLED = unsafeCastStringToDOMTopLevelType('stalled');\n    var TOP_SUSPEND = unsafeCastStringToDOMTopLevelType('suspend');\n    var TOP_TEXT_INPUT = unsafeCastStringToDOMTopLevelType('textInput');\n    var TOP_TIME_UPDATE = unsafeCastStringToDOMTopLevelType('timeupdate');\n    var TOP_TOGGLE = unsafeCastStringToDOMTopLevelType('toggle');\n    var TOP_TOUCH_CANCEL = unsafeCastStringToDOMTopLevelType('touchcancel');\n    var TOP_TOUCH_END = unsafeCastStringToDOMTopLevelType('touchend');\n    var TOP_TOUCH_MOVE = unsafeCastStringToDOMTopLevelType('touchmove');\n    var TOP_TOUCH_START = unsafeCastStringToDOMTopLevelType('touchstart');\n    var TOP_TRANSITION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('transitionend'));\n    var TOP_VOLUME_CHANGE = unsafeCastStringToDOMTopLevelType('volumechange');\n    var TOP_WAITING = unsafeCastStringToDOMTopLevelType('waiting');\n    var TOP_WHEEL = unsafeCastStringToDOMTopLevelType('wheel'); // List of events that need to be individually attached to media elements.\n    // Note that events in this list will *not* be listened to at the top level\n    // unless they're explicitly whitelisted in `ReactBrowserEventEmitter.listenTo`.\n\n    var findDOMNode = ReactDOM.findDOMNode; // Keep in sync with ReactDOMUnstableNativeDependencies.js\n    // and ReactDOM.js:\n\n    var _ReactDOM$__SECRET_IN = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Events;\n    var getInstanceFromNode = _ReactDOM$__SECRET_IN[0];\n    var getNodeFromInstance = _ReactDOM$__SECRET_IN[1];\n    var getFiberCurrentPropsFromNode = _ReactDOM$__SECRET_IN[2];\n    var injectEventPluginsByName = _ReactDOM$__SECRET_IN[3];\n    var eventNameDispatchConfigs = _ReactDOM$__SECRET_IN[4];\n    var accumulateTwoPhaseDispatches = _ReactDOM$__SECRET_IN[5];\n    var accumulateDirectDispatches = _ReactDOM$__SECRET_IN[6];\n    var enqueueStateRestore = _ReactDOM$__SECRET_IN[7];\n    var restoreStateIfNeeded = _ReactDOM$__SECRET_IN[8];\n    var dispatchEvent = _ReactDOM$__SECRET_IN[9];\n    var runEventsInBatch = _ReactDOM$__SECRET_IN[10];\n\n    function Event(suffix) {}\n\n    var hasWarnedAboutDeprecatedMockComponent = false;\n    /**\n     * @class ReactTestUtils\n     */\n\n    /**\n     * Simulates a top level event being dispatched from a raw event that occurred\n     * on an `Element` node.\n     * @param {number} topLevelType A number from `TopLevelEventTypes`\n     * @param {!Element} node The dom to simulate an event occurring on.\n     * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.\n     */\n\n    function simulateNativeEventOnNode(topLevelType, node, fakeNativeEvent) {\n      fakeNativeEvent.target = node;\n      dispatchEvent(topLevelType, fakeNativeEvent);\n    }\n    /**\n     * Simulates a top level event being dispatched from a raw event that occurred\n     * on the `ReactDOMComponent` `comp`.\n     * @param {Object} topLevelType A type from `BrowserEventConstants.topLevelTypes`.\n     * @param {!ReactDOMComponent} comp\n     * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.\n     */\n\n\n    function simulateNativeEventOnDOMComponent(topLevelType, comp, fakeNativeEvent) {\n      simulateNativeEventOnNode(topLevelType, findDOMNode(comp), fakeNativeEvent);\n    }\n\n    function findAllInRenderedFiberTreeInternal(fiber, test) {\n      if (!fiber) {\n        return [];\n      }\n\n      var currentParent = findCurrentFiberUsingSlowPath(fiber);\n\n      if (!currentParent) {\n        return [];\n      }\n\n      var node = currentParent;\n      var ret = [];\n\n      while (true) {\n        if (node.tag === HostComponent || node.tag === HostText || node.tag === ClassComponent || node.tag === ClassComponentLazy || node.tag === FunctionalComponent || node.tag === FunctionalComponentLazy) {\n          var publicInst = node.stateNode;\n\n          if (test(publicInst)) {\n            ret.push(publicInst);\n          }\n        }\n\n        if (node.child) {\n          node.child.return = node;\n          node = node.child;\n          continue;\n        }\n\n        if (node === currentParent) {\n          return ret;\n        }\n\n        while (!node.sibling) {\n          if (!node.return || node.return === currentParent) {\n            return ret;\n          }\n\n          node = node.return;\n        }\n\n        node.sibling.return = node.return;\n        node = node.sibling;\n      }\n    }\n\n    function validateClassInstance(inst, methodName) {\n      if (!inst) {\n        // This is probably too relaxed but it's existing behavior.\n        return;\n      }\n\n      if (get(inst)) {\n        // This is a public instance indeed.\n        return;\n      }\n\n      var received = void 0;\n      var stringified = '' + inst;\n\n      if (Array.isArray(inst)) {\n        received = 'an array';\n      } else if (inst && inst.nodeType === ELEMENT_NODE && inst.tagName) {\n        received = 'a DOM node';\n      } else if (stringified === '[object Object]') {\n        received = 'object with keys {' + Object.keys(inst).join(', ') + '}';\n      } else {\n        received = stringified;\n      }\n\n      invariant(false, '%s(...): the first argument must be a React class instance. Instead received: %s.', methodName, received);\n    }\n    /**\n     * Utilities for making it easy to test React components.\n     *\n     * See https://reactjs.org/docs/test-utils.html\n     *\n     * Todo: Support the entire DOM.scry query syntax. For now, these simple\n     * utilities will suffice for testing purposes.\n     * @lends ReactTestUtils\n     */\n\n\n    var ReactTestUtils = {\n      renderIntoDocument: function renderIntoDocument(element) {\n        var div = document.createElement('div'); // None of our tests actually require attaching the container to the\n        // DOM, and doing so creates a mess that we rely on test isolation to\n        // clean up, so we're going to stop honoring the name of this method\n        // (and probably rename it eventually) if no problems arise.\n        // document.documentElement.appendChild(div);\n\n        return ReactDOM.render(element, div);\n      },\n      isElement: function isElement(element) {\n        return React.isValidElement(element);\n      },\n      isElementOfType: function isElementOfType(inst, convenienceConstructor) {\n        return React.isValidElement(inst) && inst.type === convenienceConstructor;\n      },\n      isDOMComponent: function isDOMComponent(inst) {\n        return !!(inst && inst.nodeType === ELEMENT_NODE && inst.tagName);\n      },\n      isDOMComponentElement: function isDOMComponentElement(inst) {\n        return !!(inst && React.isValidElement(inst) && !!inst.tagName);\n      },\n      isCompositeComponent: function isCompositeComponent(inst) {\n        if (ReactTestUtils.isDOMComponent(inst)) {\n          // Accessing inst.setState warns; just return false as that'll be what\n          // this returns when we have DOM nodes as refs directly\n          return false;\n        }\n\n        return inst != null && typeof inst.render === 'function' && typeof inst.setState === 'function';\n      },\n      isCompositeComponentWithType: function isCompositeComponentWithType(inst, type) {\n        if (!ReactTestUtils.isCompositeComponent(inst)) {\n          return false;\n        }\n\n        var internalInstance = get(inst);\n        var constructor = internalInstance.type;\n        return constructor === type;\n      },\n      findAllInRenderedTree: function findAllInRenderedTree(inst, test) {\n        validateClassInstance(inst, 'findAllInRenderedTree');\n\n        if (!inst) {\n          return [];\n        }\n\n        var internalInstance = get(inst);\n        return findAllInRenderedFiberTreeInternal(internalInstance, test);\n      },\n\n      /**\n       * Finds all instance of components in the rendered tree that are DOM\n       * components with the class name matching `className`.\n       * @return {array} an array of all the matches.\n       */\n      scryRenderedDOMComponentsWithClass: function scryRenderedDOMComponentsWithClass(root, classNames) {\n        validateClassInstance(root, 'scryRenderedDOMComponentsWithClass');\n        return ReactTestUtils.findAllInRenderedTree(root, function (inst) {\n          if (ReactTestUtils.isDOMComponent(inst)) {\n            var className = inst.className;\n\n            if (typeof className !== 'string') {\n              // SVG, probably.\n              className = inst.getAttribute('class') || '';\n            }\n\n            var classList = className.split(/\\s+/);\n\n            if (!Array.isArray(classNames)) {\n              !(classNames !== undefined) ? invariant(false, 'TestUtils.scryRenderedDOMComponentsWithClass expects a className as a second argument.') : void 0;\n              classNames = classNames.split(/\\s+/);\n            }\n\n            return classNames.every(function (name) {\n              return classList.indexOf(name) !== -1;\n            });\n          }\n\n          return false;\n        });\n      },\n\n      /**\n       * Like scryRenderedDOMComponentsWithClass but expects there to be one result,\n       * and returns that one result, or throws exception if there is any other\n       * number of matches besides one.\n       * @return {!ReactDOMComponent} The one match.\n       */\n      findRenderedDOMComponentWithClass: function findRenderedDOMComponentWithClass(root, className) {\n        validateClassInstance(root, 'findRenderedDOMComponentWithClass');\n        var all = ReactTestUtils.scryRenderedDOMComponentsWithClass(root, className);\n\n        if (all.length !== 1) {\n          throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for class:' + className);\n        }\n\n        return all[0];\n      },\n\n      /**\n       * Finds all instance of components in the rendered tree that are DOM\n       * components with the tag name matching `tagName`.\n       * @return {array} an array of all the matches.\n       */\n      scryRenderedDOMComponentsWithTag: function scryRenderedDOMComponentsWithTag(root, tagName) {\n        validateClassInstance(root, 'scryRenderedDOMComponentsWithTag');\n        return ReactTestUtils.findAllInRenderedTree(root, function (inst) {\n          return ReactTestUtils.isDOMComponent(inst) && inst.tagName.toUpperCase() === tagName.toUpperCase();\n        });\n      },\n\n      /**\n       * Like scryRenderedDOMComponentsWithTag but expects there to be one result,\n       * and returns that one result, or throws exception if there is any other\n       * number of matches besides one.\n       * @return {!ReactDOMComponent} The one match.\n       */\n      findRenderedDOMComponentWithTag: function findRenderedDOMComponentWithTag(root, tagName) {\n        validateClassInstance(root, 'findRenderedDOMComponentWithTag');\n        var all = ReactTestUtils.scryRenderedDOMComponentsWithTag(root, tagName);\n\n        if (all.length !== 1) {\n          throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for tag:' + tagName);\n        }\n\n        return all[0];\n      },\n\n      /**\n       * Finds all instances of components with type equal to `componentType`.\n       * @return {array} an array of all the matches.\n       */\n      scryRenderedComponentsWithType: function scryRenderedComponentsWithType(root, componentType) {\n        validateClassInstance(root, 'scryRenderedComponentsWithType');\n        return ReactTestUtils.findAllInRenderedTree(root, function (inst) {\n          return ReactTestUtils.isCompositeComponentWithType(inst, componentType);\n        });\n      },\n\n      /**\n       * Same as `scryRenderedComponentsWithType` but expects there to be one result\n       * and returns that one result, or throws exception if there is any other\n       * number of matches besides one.\n       * @return {!ReactComponent} The one match.\n       */\n      findRenderedComponentWithType: function findRenderedComponentWithType(root, componentType) {\n        validateClassInstance(root, 'findRenderedComponentWithType');\n        var all = ReactTestUtils.scryRenderedComponentsWithType(root, componentType);\n\n        if (all.length !== 1) {\n          throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for componentType:' + componentType);\n        }\n\n        return all[0];\n      },\n\n      /**\n       * Pass a mocked component module to this method to augment it with\n       * useful methods that allow it to be used as a dummy React component.\n       * Instead of rendering as usual, the component will become a simple\n       * <div> containing any provided children.\n       *\n       * @param {object} module the mock function object exported from a\n       *                        module that defines the component to be mocked\n       * @param {?string} mockTagName optional dummy root tag name to return\n       *                              from render method (overrides\n       *                              module.mockTagName if provided)\n       * @return {object} the ReactTestUtils object (for chaining)\n       */\n      mockComponent: function mockComponent(module, mockTagName) {\n        if (!hasWarnedAboutDeprecatedMockComponent) {\n          hasWarnedAboutDeprecatedMockComponent = true;\n          lowPriorityWarning$1(false, 'ReactTestUtils.mockComponent() is deprecated. ' + 'Use shallow rendering or jest.mock() instead.\\n\\n' + 'See https://fb.me/test-utils-mock-component for more information.');\n        }\n\n        mockTagName = mockTagName || module.mockTagName || 'div';\n        module.prototype.render.mockImplementation(function () {\n          return React.createElement(mockTagName, null, this.props.children);\n        });\n        return this;\n      },\n      nativeTouchData: function nativeTouchData(x, y) {\n        return {\n          touches: [{\n            pageX: x,\n            pageY: y\n          }]\n        };\n      },\n      Simulate: null,\n      SimulateNative: {}\n    };\n    /**\n     * Exports:\n     *\n     * - `ReactTestUtils.Simulate.click(Element)`\n     * - `ReactTestUtils.Simulate.mouseMove(Element)`\n     * - `ReactTestUtils.Simulate.change(Element)`\n     * - ... (All keys from event plugin `eventTypes` objects)\n     */\n\n    function makeSimulator(eventType) {\n      return function (domNode, eventData) {\n        !!React.isValidElement(domNode) ? invariant(false, 'TestUtils.Simulate expected a DOM node as the first argument but received a React element. Pass the DOM node you wish to simulate the event on instead. Note that TestUtils.Simulate will not work if you are using shallow rendering.') : void 0;\n        !!ReactTestUtils.isCompositeComponent(domNode) ? invariant(false, 'TestUtils.Simulate expected a DOM node as the first argument but received a component instance. Pass the DOM node you wish to simulate the event on instead.') : void 0;\n        var dispatchConfig = eventNameDispatchConfigs[eventType];\n        var fakeNativeEvent = new Event();\n        fakeNativeEvent.target = domNode;\n        fakeNativeEvent.type = eventType.toLowerCase(); // We don't use SyntheticEvent.getPooled in order to not have to worry about\n        // properly destroying any properties assigned from `eventData` upon release\n\n        var targetInst = getInstanceFromNode(domNode);\n        var event = new SyntheticEvent(dispatchConfig, targetInst, fakeNativeEvent, domNode); // Since we aren't using pooling, always persist the event. This will make\n        // sure it's marked and won't warn when setting additional properties.\n\n        event.persist();\n\n        _assign(event, eventData);\n\n        if (dispatchConfig.phasedRegistrationNames) {\n          accumulateTwoPhaseDispatches(event);\n        } else {\n          accumulateDirectDispatches(event);\n        }\n\n        ReactDOM.unstable_batchedUpdates(function () {\n          // Normally extractEvent enqueues a state restore, but we'll just always\n          // do that since we we're by-passing it here.\n          enqueueStateRestore(domNode);\n          runEventsInBatch(event, true);\n        });\n        restoreStateIfNeeded();\n      };\n    }\n\n    function buildSimulators() {\n      ReactTestUtils.Simulate = {};\n      var eventType = void 0;\n\n      for (eventType in eventNameDispatchConfigs) {\n        /**\n         * @param {!Element|ReactDOMComponent} domComponentOrNode\n         * @param {?object} eventData Fake event data to use in SyntheticEvent.\n         */\n        ReactTestUtils.Simulate[eventType] = makeSimulator(eventType);\n      }\n    }\n\n    buildSimulators();\n    /**\n     * Exports:\n     *\n     * - `ReactTestUtils.SimulateNative.click(Element/ReactDOMComponent)`\n     * - `ReactTestUtils.SimulateNative.mouseMove(Element/ReactDOMComponent)`\n     * - `ReactTestUtils.SimulateNative.mouseIn/ReactDOMComponent)`\n     * - `ReactTestUtils.SimulateNative.mouseOut(Element/ReactDOMComponent)`\n     * - ... (All keys from `BrowserEventConstants.topLevelTypes`)\n     *\n     * Note: Top level event types are a subset of the entire set of handler types\n     * (which include a broader set of \"synthetic\" events). For example, onDragDone\n     * is a synthetic event. Except when testing an event plugin or React's event\n     * handling code specifically, you probably want to use ReactTestUtils.Simulate\n     * to dispatch synthetic events.\n     */\n\n    function makeNativeSimulator(eventType, topLevelType) {\n      return function (domComponentOrNode, nativeEventData) {\n        var fakeNativeEvent = new Event(eventType);\n\n        _assign(fakeNativeEvent, nativeEventData);\n\n        if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {\n          simulateNativeEventOnDOMComponent(topLevelType, domComponentOrNode, fakeNativeEvent);\n        } else if (domComponentOrNode.tagName) {\n          // Will allow on actual dom nodes.\n          simulateNativeEventOnNode(topLevelType, domComponentOrNode, fakeNativeEvent);\n        }\n      };\n    }\n\n    [[TOP_ABORT, 'abort'], [TOP_ANIMATION_END, 'animationEnd'], [TOP_ANIMATION_ITERATION, 'animationIteration'], [TOP_ANIMATION_START, 'animationStart'], [TOP_BLUR, 'blur'], [TOP_CAN_PLAY_THROUGH, 'canPlayThrough'], [TOP_CAN_PLAY, 'canPlay'], [TOP_CANCEL, 'cancel'], [TOP_CHANGE, 'change'], [TOP_CLICK, 'click'], [TOP_CLOSE, 'close'], [TOP_COMPOSITION_END, 'compositionEnd'], [TOP_COMPOSITION_START, 'compositionStart'], [TOP_COMPOSITION_UPDATE, 'compositionUpdate'], [TOP_CONTEXT_MENU, 'contextMenu'], [TOP_COPY, 'copy'], [TOP_CUT, 'cut'], [TOP_DOUBLE_CLICK, 'doubleClick'], [TOP_DRAG_END, 'dragEnd'], [TOP_DRAG_ENTER, 'dragEnter'], [TOP_DRAG_EXIT, 'dragExit'], [TOP_DRAG_LEAVE, 'dragLeave'], [TOP_DRAG_OVER, 'dragOver'], [TOP_DRAG_START, 'dragStart'], [TOP_DRAG, 'drag'], [TOP_DROP, 'drop'], [TOP_DURATION_CHANGE, 'durationChange'], [TOP_EMPTIED, 'emptied'], [TOP_ENCRYPTED, 'encrypted'], [TOP_ENDED, 'ended'], [TOP_ERROR, 'error'], [TOP_FOCUS, 'focus'], [TOP_INPUT, 'input'], [TOP_KEY_DOWN, 'keyDown'], [TOP_KEY_PRESS, 'keyPress'], [TOP_KEY_UP, 'keyUp'], [TOP_LOAD_START, 'loadStart'], [TOP_LOAD_START, 'loadStart'], [TOP_LOAD, 'load'], [TOP_LOADED_DATA, 'loadedData'], [TOP_LOADED_METADATA, 'loadedMetadata'], [TOP_MOUSE_DOWN, 'mouseDown'], [TOP_MOUSE_MOVE, 'mouseMove'], [TOP_MOUSE_OUT, 'mouseOut'], [TOP_MOUSE_OVER, 'mouseOver'], [TOP_MOUSE_UP, 'mouseUp'], [TOP_PASTE, 'paste'], [TOP_PAUSE, 'pause'], [TOP_PLAY, 'play'], [TOP_PLAYING, 'playing'], [TOP_PROGRESS, 'progress'], [TOP_RATE_CHANGE, 'rateChange'], [TOP_SCROLL, 'scroll'], [TOP_SEEKED, 'seeked'], [TOP_SEEKING, 'seeking'], [TOP_SELECTION_CHANGE, 'selectionChange'], [TOP_STALLED, 'stalled'], [TOP_SUSPEND, 'suspend'], [TOP_TEXT_INPUT, 'textInput'], [TOP_TIME_UPDATE, 'timeUpdate'], [TOP_TOGGLE, 'toggle'], [TOP_TOUCH_CANCEL, 'touchCancel'], [TOP_TOUCH_END, 'touchEnd'], [TOP_TOUCH_MOVE, 'touchMove'], [TOP_TOUCH_START, 'touchStart'], [TOP_TRANSITION_END, 'transitionEnd'], [TOP_VOLUME_CHANGE, 'volumeChange'], [TOP_WAITING, 'waiting'], [TOP_WHEEL, 'wheel']].forEach(function (_ref) {\n      var topLevelType = _ref[0],\n          eventType = _ref[1];\n      /**\n       * @param {!Element|ReactDOMComponent} domComponentOrNode\n       * @param {?Event} nativeEventData Fake native event to use in SyntheticEvent.\n       */\n\n      ReactTestUtils.SimulateNative[eventType] = makeNativeSimulator(eventType, topLevelType);\n    });\n    var ReactTestUtils$2 = Object.freeze({\n      default: ReactTestUtils\n    });\n    var ReactTestUtils$3 = ReactTestUtils$2 && ReactTestUtils || ReactTestUtils$2; // TODO: decide on the top-level export form.\n    // This is hacky but makes it work with both Rollup and Jest.\n\n    var testUtils = ReactTestUtils$3.default || ReactTestUtils$3;\n    module.exports = testUtils;\n  })();\n}","map":null,"metadata":{},"sourceType":"script"}